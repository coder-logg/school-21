# push_swap
[**visualizer**](https://github.com/o-reo/push_swap_visualizer) \
**Алгоритмы решения:**\
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [алгоритм №1](https://vk.com/@forum42intra-push-swap) \
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [алгоритм №2](https://medium.com/@jamierobertdawson/push-swap-the-least-amount-of-moves-with-two-stacks-d1e76a71789a) \
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [решение от VBrazhnik](https://github.com/VBrazhnik/Push_swap/wiki/Algorithm)

#### Ограничения по количсетву операций
* 3 элемента: < 3
* 5 элементов: < 12
* 100 чичсел:
  * 5 баллов — < 700 
  * 4 балла — < 900
  * 3 балла — < 1100
  * 2 балла — < 1300
  * 1 балл — < 1500
* 500 чисел:
  * 5 баллов — < 5500
  * 4 балла — < 7000
  * 3 балла — < 8500
  * 2 балла — < 10000
  * 1 балл — < 11500
  
------
* Этот проект будут проверять только настоящие люди. Таким образом,
  вы можете свободно организовывать и называть свои файлы по своему усмотрению,
  хотя вам необходимо соблюдать некоторые требования, перечисленные ниже.
* Исполняемый файл должен называться push_swap.
* Вы должны отправить Makefile. Этот Makefile должен скомпилировать проект и содержать обычные правила. Он может только перекомпилировать программу при необходимости.
* Если вы умен, вы будете использовать свою библиотеку для этого проекта, отправьте также свою папку libft, включая собственный Makefile в корне вашего репозитория. Ваш Makefile должен будет скомпилировать библиотеку, а затем скомпилировать ваш проект.
* Глобальные переменные запрещены.
* Ваш проект должен быть написан на C в соответствии с Нормой.
* Вы должны деликатно обращаться с ошибками. Ни в коем случае ваша программа не может завершиться неожиданным образом (ошибка сегментации, ошибка шины, двойное освобождение и т. Д.).
* Ни одна из программ не может иметь утечек памяти.
* В рамках обязательной части вам разрешено использовать следующие функции:
  * write
  * read
  * malloc
  * free
  * exit
* Вы можете задавать вопросы на форуме и в Slack ...
  
## Основная часть
### Правила игры
* Игра состоит из 2 [стеков](https://ru.wikipedia.org/wiki/%D0%A1%D1%82%D0%B5%D0%BA), названных a и b.
* В начале:
    * a содержит случайное число положительных или отрицательных чисел без дубликатов.
    * b пусто
* Цель состоит в том, чтобы отсортировать числа в порядке возрастания в стопку a.
* Для этого в вашем распоряжении следующие операции:
  * sa: swap a - поменять местами первые 2 элемента на вершине стека a. Ничего не делать, если есть только один или нет элементов).
  * sb: swap b - поменять местами первые 2 элемента на вершине стека b. Ничего не делать, если есть только один или нет элементов).
  * ss: sa и sb одновременно.
  * pa: push a - возьмите первый элемент вверху b и поместите его вверху a. Ничего не делать, если b пусто.
  * pb: push b - возьмите первый элемент вверху a и поместите его вверху b. Ничего не делать, если a пусто.
  * ra: rotate a - сдвинуть вверх все элементы стека a на 1. Первый элемент становится последним.
  * rb: rotate b - сдвинуть вверх все элементы стека b на 1. Первый элемент становится последним.
  * rr: ra и rb одновременно.
  * rra: reverse rotate a - сдвинуть вниз все элементы стека a на 1. Последний элемент становится первым.
  * rrb: reverse rotate b - сдвинуть вниз все элементы стека b на 1. Последний элемент становится первым.
  * rrr: rra и rrb одновременно.
    
### Примеры
Чтобы проиллюстрировать действие некоторых из этих инструкций, давайте отсортируем случайный список целых чисел.
В этом примере мы будем считать, что оба стека растут справа.
````shell
----------------------------------------------------------------------------------------------------------
Init a and b:
2
1
3
6
5
8
_ _
a b
----------------------------------------------------------------------------------------------------------
Exec sa:
1
2
3
6
5
8
_ _
a b
----------------------------------------------------------------------------------------------------------
Exec pb pb pb:
6 3
5 2
8 1
_ _
a b
----------------------------------------------------------------------------------------------------------
Exec ra rb (equiv. to rr):
5 2
8 1
6 3
_ _
a b
----------------------------------------------------------------------------------------------------------
Exec rra rrb (equiv. to rrr):
6 3
5 2
8 1
_ _
a b
----------------------------------------------------------------------------------------------------------
Exec sa:
5 3
6 2
8 1
_ _
a b
----------------------------------------------------------------------------------------------------------
Exec pa pa pa:
1
2
3
5
6
8
_ _
a b
----------------------------------------------------------------------------------------------------------
````

### “push_swap” program
* Вы должны написать программу с именем push_swap, которая будет получать в качестве аргумента стек,
  отформатированный как список целых чисел. Первый аргумент должен быть наверху стека
  (будьте осторожны с порядком).
* Программа должна отображать наименьший возможный список инструкций для сортировки стека a, причем
  наименьшее число должно быть вверху.
* Инструкции должны разделяться символом `\n` и ничем другим.
* Цель состоит в том, чтобы отсортировать стек с минимально возможным количеством операций.
  Во время защиты мы сравним количество инструкций, найденных вашей программой, с максимально допустимым 
  количеством операций. Если ваша программа отображает слишком большой список или список не отсортирован
  должным образом, вы не получите баллов.
* В случае ошибки вы должны отобразить ошибку, за которой следует `\n` для стандартной ошибки.
  К ошибкам относятся, например: некоторые аргументы не являются целыми числами, некоторые аргументы
  больше размера int'а и / или есть дубликаты.
  
````shell
$>./push_swap 2 1 3 6 5 8
sa
pb
pb
pb
sa
pa
pa
pa
$>./push_swap 0 one 2 3
Error
$>
````

Во время защиты мы предоставим двоичный код для правильной проверки вашей программы.
Это будет работать следующим образом:

````shell
$>ARG="4 67 3 87 23"; ./push_swap $ARG | wc -l
6
$>ARG="4 67 3 87 23"; ./push_swap $ARG | ./checker_OS $ARG
OK
$>
````

Если программа checker_OS отображает KO, это означает, что ваш push_swap выдал список инструкций,
которые не сортируют список. Программа checker_OS доступна в ресурсах проекта в интранете.
Вы можете найти в бонусном разделе этого документа описание того, как это работает.

## Бонусная часть
Мы рассмотрим вашу бонусную часть тогда и только тогда, когда ваша обязательная часть ОТЛИЧНО.
Это означает, что вы должны выполнить обязательную часть от начала до конца, а управление ошибками
должно быть безупречным, даже в случаях неправильного использования.
Если это не так, ваши бонусы будут полностью ИГНОРИРОВАНЫ.

### “checker” program
* Напишите программу с именем checker, которая получит в качестве аргумента стек,
отформатированный как список целых чисел. Первый аргумент должен быть наверху стека
(будьте осторожны с порядком). Если аргумент не задан, проверка останавливается и ничего не отображает.
  
* Затем checker будет ждать и читать инструкции на стандартном вводе, за каждой инструкцией будет следовать
  `\n`. Как только все инструкции будут прочитаны, программа проверки выполнит их в стеке, полученном в 
  качестве аргумента.
    
* Если после выполнения этих инструкций стек `a` фактически отсортирован, а `b` пуст, тогда программа проверки
  должна отобразить на стандартном выводе `OK`, за которым следует `\n`. Во всех остальных случаях программа
  проверки должна отображать `KO` с последующим `\n` на стандартном выводе.
  
* В случае ошибки вы должны отобразить `Error`, за которым следует `\n` на стандартный вывод ошибок. К ошибкам относятся,
  например: некоторые аргументы не являются целыми числами, некоторые аргументы больше целого числа, есть дубликаты,
  инструкция не существует и / или имеет неправильный формат.
  
```shell
$>./checker 3 2 1 0
rra
pb
sa
rra
pa
OK
$>./checker 3 2 1 0
sa
rra
pb
KO
$>./checker 3 2 one 0
Error
$>
```
