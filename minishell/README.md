#  Minishell
## Основная часть

Program name | minishell
|----|----|
Turn in files | |
Makefile | Yes
Arguments | |
External functs. | `readline`, `rl_clear_history`, `rl_on_new_line`, <br>`rl_replace_line`, `rl_redisplay`, `add_history`, `printf`, <br> `malloc`, `free`, `write`, `open`, `read`, `close`, `fork`, `wait`, <br>`waitpid`, `wait3`, `wait4`, `signal`, `kill`, `exit`, `getcwd`,  <br>`chdir`, `stat`, `lstat`, `fstat`, `unlink`, `execve`, `dup`,  <br>`dup2`, `pipe`, `opendir`, `readdir`, `closedir`, `strerror`,  <br>`perror`, `isatty`, `ttyname`, `ttyslot`, `ioctl`, `getenv`,  <br>`tcsetattr`, `tcgetattr`, `tgetent`, `tgetflag`, `tgetnum`,  <br>`tgetstr`, `tgoto`, `tputs`
Libft authorized | Yes
Description | Write a shell

Ваша оболочка должна:
* Не интерпретировать незакрытые кавычки или неуказанные специальные символы, такие как `\ ` или `;`.
* Не используйте более одной глобальной переменной. Будьте готовы объяснить, почему вы сделали это.
* Показывать подсказку при ожидании новой команды.
* Иметь рабочую историю.
* Находить и запускать нужный исполняемый файл (на основе переменной `PATH` или с помощью
относительного или абсолютного пути)
* Он должен реализовывать встроенные функции:
  * `echo` с опцией `-n`
  * `cd` только с относительным или абсолютным путем
  * `pwd` без параметров
  * `export` без параметров
  * `unset` без параметров
  * `env` без параметров или аргументов
  * `exit` без параметров
* `’` запрещает любую интерпретацию последовательности символов.
* `"` запрещает любую интерпретацию последовательности символов, кроме `$`.
* Перенаправления:
  * `<` должен перенаправлять ввод.
  * `>` должен перенаправлять вывод.
  * `<<` считывать ввод из текущего источника до тех пор, пока не будет видна строка, содержащая только разделитель. Не нужно обновлять историю!
  * `>>` должен перенаправлять вывод в режиме добавления.
* Pipes `|`  — выход каждой команды в конвейере (pipeline) соединяется через `|` с входом следующей команды.
* Переменные среды (`$`, за которым следуют символы) должны раскрыться до своих значений.
* `$?` должен расшириться до статуса завершения последнего выполненного конвейера переднего плана.
* `ctrl-C` `ctrl-D` `ctrl- \ ` должен работать как в bash.
* В интерактивном режиме:
  * `ctrl-C` печатает новое приглашение на новой строке.
  * `ctrl-D` выйти из оболочки.
  * `ctrl- \ ` ничего не делать.

Функция `readline` может вызвать некоторую утечку, которую не нужно исправлять.
Но будьте осторожны, ваш собственный код не должен давать утечек.
Следует ограничиться описанием.
Ничего, о чем не спрашивали, не требуется.
По каждому пункту, если у вас есть сомнения, используйте `bash` в качестве справочника.